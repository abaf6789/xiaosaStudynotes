# HTTP协议

## HTTP协议的主要特点

- 简单快速

  每个资源url都是固定的，一个页面地址一张图片叫做统一资源定位符（URL），这个是固定的，所以在http协议中处理也是非常简单的。我想访问某一个地址，只要输入这个url就可以了

- 灵活

  在http协议中有一个头部分会有一个数据类型，通过一个http协议就可以完成不同数据类型的传输

- 无连接

  连接一次它就会断掉，不会保持连接

- 无状态

  客户端和服务端是两种身份，客户端需要向服务端请求一个图片，那么http协议建立连接，帮你中间传输。这次任务完成以后，连接就断开了，下次客户端再过来服务器是无法区分上一次连接和这一次连接是不是同一个身份。因为服务器是没有记住你的状态的。单从http协议上是不能区分两次连接者的身份的。

## HTTP报文的组成部分（有请求有回应）

浏览器向服务器要一个html文档或者一个图片，输入了慕课网的url地址，相当于客户端发出的请求报文，发出去了，服务端接收到了以后做出响应，要不要给你这份文档的内容，**这个就是响应报文**。

1. 请求报文：

   - 请求行（GET/HTTP/1.1）

     包含：http方法、页面地址、http协议、版本

   - 请求头

     key、value值来告诉服务端要哪些内容，注意哪些类型

   - 空行

     当遇到空行就知道不再是请求头部分了，就应该当成请求体来解析

   - 请求体

2. 响应报文

   - 状态行（HTTP/1.1 200OK—http状态码）

   - 响应头

     key、value值来告诉服务端要哪些内容、注意哪些类型

   - 空行

   - 响应体

     比如给的html文档部分就是响应体部分

## HTTP方法

- GET		获取资源
- POST      传输资源
- PUT        更新资源
- DELETE  删除资源（一般用不到）
- HEAD     获取报文首部（一般用不到）

## GET和POST的区别

- GET在浏览器后退时是无害的，而POST会再次提交请求

- GET请求会被浏览器主动缓存，而POST不会，除非手动设置

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会保留

  想把参数留在浏览器历史记录里用GET，做业务开发的时候为了防止CRSF攻击，公司里都把GET请求改成POST，如果业务需要把参数留在浏览器历史记录中就改回GET

- GET请求在URL中传送的参数是有长度限制的（2kb），而POST没有限制

- GET参数通过URL传递，POST放在Request body中

  ## **HTTP状态码**

  ```
      1xx: 提示信息--表示请求已接收，继续处理
      
      2xx：成功--表示请求已被成功接收
      
          200 OK：客户端请求成功
          206 Partial Content：客户端发送了一个带有Range（范围）头的GET请求，服务器完成了它
          （客户端请求一部分内容，在http head头中有一个range范围，请求0-10000字节，服务器就
  返回一个206，服务器的文件是完整的，这个时候看到range头，按照range头从整个文件中截取一部分响应
  给你，你响应体中只有你range头中指定的内容）
    使用video播放视频地址，audio播放音频地址，当视频文件、音频文件很大的时候基本都是返回的206;
     
      3xx：重定向--要完成请求必须进行更进一步的操作
      
          301 Moved Permanently：（永久重定向）所请求的页面已经转移至新的url
          302 Found：            （临时重定向）所请求的页面已经临时转移至新的url
          304 Not Modified：     客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户,
  原来缓冲的文档还可以继续使用。
          --服务器告诉浏览器已经有缓存了，可以直接从缓存中去取文档用，不用去服务器取了
              
      4xx：客户端错误--请求有语法错误或请求无法实现
      
          400 Bad Request：客户端请求有语法错误，不能被服务器所理解；
          401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用;
          403 Forbidden：对被请求页面的访问被禁止；（资源禁止被访问）
              --看到一个页面中一个地址，这个地址真的访问又不允许直接访问，只能通过服务器去访问;
          404 Not Found：请求资源不存在；
      
      5xx：服务器错误--服务器未能实现合法的请求
      
          500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用；
          503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常；
  ```

  ​

## HTTP持久连接（HTTP是支持持久连接的，1.1版本支持，1.0不支持）

### 非持久连接

HTTP协议采用”请求--应答“模式，当使用普通模式，即非Keep-Alive（持久连接）模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

### 持久连接

当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端到连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或重新建立连接

## 管线化

请求和响应共用一个通道，这个通道是持久建立的，不是我请求一次你响应一次，而是把请求打包一次传输过去，你也打包一次响应过来

 **在使用持久连接的情况下，某个连接上消息的传递类似于：**
    **请求1-->响应1-->请求2-->响应2-->请求3-->响应3（表示整个连接没有中断过）**

 **某个连接上的消息变成了类似这样：（持久连接情况下完成的管线化）**
    **请求1-->请求2-->请求3-->响应1-->响应2-->响应3**

### 管线化的特点

- 管线化机制通过持久连接完成，仅HTTP/1.1支持此技术
- 只有GET和HEAD请求可以进行管线化，而POST则有所限制
- 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议
- 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
- HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
- 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持

### 总结：

- 工作原理：将请求响应打包回来
- 特点：通过持久连接完成，需要HTTP/1.1支持
- 只有GET和HEAD请求可以进行管线化，POST有所限制
- 连接的时候不要启动管线限制，因为对方可能不支持（初次连接的时候）

## 一个页面从输入URL到页面加载显示完成，经历了什么

1. 首先，在浏览器地址中输入URL。
2. 浏览器先查看**浏览器缓存**-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示网页内容。
3. 若没有缓存，在发送HTTP请求前，需要**域名解析**（DNS解析），解析获取相应的IP地址。
4. 浏览器向服务器发起**TCP连接**，与浏览器建立**TCP三次握手**。
5. 握手成功后，浏览器向服务器发送**HTTP请求，请求数据包**。
6. **服务器处理收到的请求**，将数据返回至浏览器。
7. **浏览器收到HTTP响应**
8. 读取页面内容，**浏览器渲染**，解析HTML源码
9. 生成DOM树，解析CSS样式和JS交互
10. 客户端和服务器交互
11. AJAX查询